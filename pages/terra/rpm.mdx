---
title: RPM Documentations
description: "Documentations on most RPM Features."
---

import { Callout } from "nextra/components";
import { Split } from "../../components/split";

# RPM Documentations

This document covers most if not all useful RPM features.

## Foreword

We understand that RPM, as one of the components in the Fedora / RedHat ecosystem,
is one of the most undocumented packaging systems, and we would like to change that.
We believe by thoroughly documenting Fedora-specific and other RPM macros, we could
make packaging easier to get started for everyone.
Providing the most up-to-date RPM documentations on the Internet could benefit everyone
in the ecosystem, which is why we made this lengthy list of macros.

We provided this document pretty without any restrictions, i.e. you have the freedom
to do whatever you want. However, we would really appreciate if you could also give back
to Terra, packaging a few apps you find possibly useful to other people using Fedora into Terra.

We hope you find this document useful.

## Sections and Steps

### Preamble

The preamble section is the "default" section of an RPM spec file. All spec files begin with a preamble
section that stretches from the top until a new section (e.g. `%description`) is reached.

In Fedora, a preamble is also referred to as a "tag" or a "field".[^1]

Here is a non-exclusive (but nearly exclusive) list of preambles available:

```rpmspec
## these fields MUST be present in a spec file

Name:           pkgname
Version:        1.2.3
Release:        1%?dist
Summary:        Package summary (usually do not add period at the end)
# As opposed to the guidelines given by RPM, we (and also Fedora!) strongly
# recommend using SPDX identifiers.
License:        MIT
URL:            https://terra.fyralabs.com/

## terra also enforces the following preamble:

Packager:       username <email@example.com>

## these fields are optional and have default values

Epoch:          0
AutoReqProv:    1
AutoReq:        1
AutoProv:       1

## these fields are optional

SourceLicense:
BugURL:
ModularityLabel:
DistTag:
VCS:
Distribution:
Copyright:
Vendor:
ExcludeArch:
ExclusiveArch:
ExcludeOS:
ExclusiveOS:
BuildArch:
BuildArchitectures:
BuildRequires:

Group:
Provides:
Obsoletes:
Conflicts:
Suggests:
Recommends:
Enhances:
Supplements:

OrderWithRequires:
BuildConflicts:
Prefix:
Prefixes:
Docdir:
RemovePathPostFixes:

BuildSystem:
BuildOption:
```

<Callout type="warning">
  If you want to add comments, use `%{dnl:‚Ä¶}` or start a new line.
  Adding `# ‚Ä¶` at the end of a line does not work.
</Callout>

`BuildSystem:{:rpmspec}` is a relatively new RPM feature.[^2]


## RPM Macros

Technically, there are 3 types of "macros":
- `%{rpm_macro}`: Normal RPM macros
- `%(echo "hi" | sed 's/hi/hello/')`: Shell macros that expands to the output of the commands
- `%[v"1.2.3~1" < v"1.2.3"]`: RPM [expression]

This section only covers the first type.

### Legend

- üî¢ : Parameterized macro.
- üî¶ : Relatively uncommon.
- üî∞ : Relatively common.
- üö∏ : Not recommended in Terra.
- üõ†Ô∏è : Advanced.
- üî© : Usually used with `rpm -E` but not in spec files.

### RPM Built-in Macros

#### Macro Manipulation

<Callout type="info">
  This list is obtained from [rpmspec-rs](https://github.com/rpm-rs/rpmspec-rs/blob/464c8caab5d451517691cc2885bd77912aa53190/src/macros.rs),
  which is obtained from [RPM docs](https://github.com/rpm-software-management/rpm/blob/b043604b9eb684dc761aeacf55a784632ca0ebcd/docs/manual/macros.md#builtin-macros).
</Callout>

##### `%define` üî∞

Defines a macro locally.

Macros defined with `%define` will not last to another RPM section.
For example, if used in preamble section, the macro will be automatically undefined in `%prep`.

To make sure a macro lasts for the entire spec file, use `%global` instead.

<Split>
  <Split.Left>
    ```rpmspec filename="example.spec"
    %build
    %define my_macro Hello, World!
    echo %my_macro

    %install
    echo %my_macro
    ```
  </Split.Left>
  <Split.Right>
    ```rpmspec filename="expand.spec"
    %build
    echo Hello, World!

    %install
    echo %my_macro
    ```
  </Split.Right>
</Split>

##### `%global` üî∞

Defines a macro globally.

As oppose to [`%define`](#define-), macros defined with `%global` will last for the entire spec file.

<Split>
  <Split.Left>
    ```rpmspec filename="example.spec"
    %global cat Meow!!!

    %prep
    echo nya %cat

    %build
    echo %cat
    ```
  </Split.Left>
  <Split.Right>
    ```rpmspec filename="expand.spec"
    %prep
    echo nya Meow!!!

    %build
    echo Meow!!!
    ```
  </Split.Right>
</Split>

##### `%undefine` üî¶

Undefine a macro.

Technically this does not always undefine the macro specified.
Instead, this pops the latest definition from the macro stack.

<Split>
  <Split.Left>
    ```rpmspec filename="example.spec"
    %global cat Meow!

    %prep
    %global cat Nyaa!
    echo %cat

    %build
    %undefine cat
    echo %cat

    %install
    %undefine cat
    echo %cat
    ```
  </Split.Left>
  <Split.Right>
    ```rpmspec filename="expand.spec"
    %prep
    echo Nyaa!

    %build
    echo Meow!

    %install
    echo %cat
    ```
  </Split.Right>
</Split>

##### `%dnl` üî∞

Comments.

Similar to `# ‚Ä¶`, this can comment out anything in `%{dnl:‚Ä¶}` or after `%dnl ‚Ä¶`.
The difference with `# ‚Ä¶` is that `%dnl` prevents macro expansions,
while macros in `# ‚Ä¶` are actually expanded.

<Split>
  <Split.Left>
    ```rpmspec filename="example.spec"
    %define meow a
    # comment %meow
    %dnl comment %meow
    ```
  </Split.Left>
  <Split.Right>
    ```rpmspec filename="expand.spec"
    # comment a
    ```
  </Split.Right>
</Split>

##### `%{load:‚Ä¶}` üî¶üö∏

Load a macro file.

##### `%{expr:‚Ä¶}` üî¶

Expand all macros in the body, then evaluate the body as an [expression].

  ```sh
  $ rpm -D 'foo 1 + 2' -E '%[%foo]'
  error: macro expansion did not return an integer: %foo
  error:                                            ^
  error: expanded string: 1 + 2

  $ rpm -D 'foo 1 + 2' -E '%{expr:%foo}'
  3
  ```

##### `%{expand:‚Ä¶}` üõ†Ô∏è

  Double-expand the macro.

  <Split>
    <Split.Left>
      ```rpmspec filename="example.spec"
      %define nya foo
      %define meow %{expand:%%nya}
    
      echo %meow
      ```
    </Split.Left>
    <Split.Right>
      ```rpmspec filename="expand.spec"
      echo foo
      ```
    </Split.Right>
  </Split>

##### `%{lua:‚Ä¶}` üõ†Ô∏è

Embed lua code.

<Callout type="warning">
  Since RPM expands macros when the source RPM (SRPM) is created,
  the lua code is executed during that stage.

  This means that the lua code is executed not during the stage it is defined in, but
  way before even `%prep`.
</Callout>
<Callout type="warning">
  Do NOT comment out lua code using `# ‚Ä¶`, `%dnl ‚Ä¶` or `%{dnl:‚Ä¶}`.

  Lua comments must start with `-- ‚Ä¶`.

  In `rpmspec-rs`, a space must be present after `--`.
</Callout>
<Callout type="info">
  Documentations for the embedded Lua interpreter, including specific functions available,
  are available at https://rpm-software-management.github.io/rpm/manual/lua.html.
</Callout>

<Split>
  <Split.Left>
    ```rpmspec filename="example.spec"
    %global my_macro Hello
    %{lua:
      -- this lua block expands to the input
      -- to all `print()` statements
      print("%prep\necho " ..
        rpm.expand("%my_macro from lua!") ..
        "\n")
    }
    ```
  </Split.Left>
  <Split.Right>
    ```rpmspec filename="expand.spec"
    %prep
    echo Hello from lua!
    ```
  </Split.Right>
</Split>

##### `%{macrobody:‚Ä¶}` üî©

Expand to the definition of the given macro.

```sh
$ rpm -E '%dist'
.um41

$ rpm -E '%macrobody dist'
%{?distprefix}.um41%{?with_bootstrap:~bootstrap}
```

##### `%{quote:‚Ä¶}` üî¶üõ†Ô∏è

Does nothing. You heard me, this macro literally does nothing.

But because of that it's very useful.
This can be used to pass arguments with spaces to parameterized macros:

<Split>
  <Split.Left>
    ```rpmspec filename="example.spec"
    echo %gsub %{quote:hello hello} %{quote:^hello} bye
    ```
  </Split.Left>
  <Split.Right>
    ```rpmspec filename="expand.spec"
    echo bye hello
    ```
  </Split.Right>
</Split>


#### String Operations

##### `%gsub ‚Ä¶` üî¢üî¶üõ†Ô∏è

Equivalent to `%{lua: string.gsub("%1", "%2", %3, %?4)}`,
where `%n` represents the n-th argument to `%gsub`.

In short, this replaces `%?4` occurrences of `%2` in `%1` to `%3`.
`%4` is optional and defaults to infinity.

`%2` is treated as a [lua pattern](https://www.lua.org/pil/20.2.html).

<Split>
  <Split.Left>
    ```rpmspec filename="example.spec"
    echo %gsub %{quote:hello hello} %{quote:^hello} bye
    ```
  </Split.Left>
  <Split.Right>
    ```rpmspec filename="expand.spec"
    echo bye hello
    ```
  </Split.Right>
</Split>

##### `%{len:‚Ä¶}`

Obtains the length of the given text.

<Split>
  <Split.Left>
    ```rpmspec filename="example.spec"
    %define foo meow now!
    echo %{len:%foo}
    ```
  </Split.Left>
  <Split.Right>
    ```rpmspec filename="expand.spec"
    echo 9
    ```
  </Split.Right>
</Split>

##### `%{lower:‚Ä¶}`

Turn the input into ASCII-lowercase.

##### `%{upper:‚Ä¶}`

ASCII-uppercase.

##### `%rep ‚Ä¶` üî¢üî¶

Repeat the first input (`%1`) `n`-times, `n` given by `%2` (lua `string.rep()`).

##### `%{reverse:‚Ä¶}`

##### `%sub ‚Ä¶` üî¢üî∞

Expand to substring (lua `string.sub()`).

```sh
$ rpm -E '%sub abc 2 3' 
bc
```

##### `%{shescape:‚Ä¶}`

Wrap the input with single quotes and also escape preexisting single-quotes correctly,
so that the input can be safely passed as arguments to shell commands.

```sh
$ rpm -E "echo %{shescape:this is some 'text'}"
echo 'this is some '\''text'\'''

$ rpm -E "%(echo %{shescape:this is some 'text'})"
this is some 'text'
```

##### `%{shrink:‚Ä¶}`

Trim leading and trailing ASCII-whitespace, and reduce intermediate whitespace to a single space.


#### File and Path Operations

##### `%{basename:‚Ä¶}` üî¶

> basename(1) macro analogue

##### `%{dirname:‚Ä¶}` üî¶

> dirname(1) macro analogue

##### `%{exists:‚Ä¶}` üî¶

> test file existence, expands to 1/0

##### `%{suffix:‚Ä¶}` üî¶

> expand to suffix part of a file name

##### `%{url2path:‚Ä¶}` üî¶

> convert url to a local path

##### `%{uncompress:‚Ä¶}`

> expand to a command for outputting argument file to stdout, uncompressing as needed

This macro is used in [`%setup ‚Ä¶`](#setup--) for uncompressing source files.


#### Environment info

##### `%{getncpus:‚Ä¶}`

When used as `%{getncpus}` with no arguments, expand to the number of available CPU cores.

Also accept extra arguments:

> accepts arguments `total`, `proc` and `thread`, additionally accounting for available memory (e.g. address space limitations for threads)

However, `%getncpus total`, `%getncpus proc` and `%getncpus thread` produce the same results as far as
concerned. It is suspected that the arguments in most cases have no effect to the output.

##### `%getconfdir` üî¶

> expand to rpm "home" directory (typically /usr/lib/rpm)

##### `%{getenv:...}` üî¶

> getenv(3) macro analogue

##### `%rpmversion` üî¶

> expand to running rpm version

#### Output

##### `%{echo:‚Ä¶}` üî¶

> print ... to stdout

<Callout type="warning">
  The printing happens when the macro is evaluated and expanded, not at the section/position it is written.
</Callout>

##### `%{warn:‚Ä¶}` üî¶

> print warning: ... to stderr 	

Produce an RPM warning, which is immediately shown in console stderr,
and displayed again at the end of the `rpmbuild` execution (after `Executing(rmbuild)`).

<Callout type="warning">
  The printing happens when the macro is evaluated and expanded, not at the section/position it is written.
</Callout>

##### `%{error:‚Ä¶}` üî¶

> print error: ... to stderr and return an error 	

Produce an RPM warning, which is immediately shown in console stderr, then immediately
perform `Executing(rmbuild)` and exit with a summary of all warnings and errors.

<Callout type="warning">
  The printing happens when the macro is evaluated and expanded, not at the section/position it is written.
</Callout>

##### `%{verbose:‚Ä¶}` üî¶

> `%verbose`: expand to 1 if rpm is in verbose mode, 0 if not 	
>
> `%{verbose:...}`: expand to ... if rpm is in verbose mode, the empty string if not


## RPM Expression

RPM expressions is a "sublanguage" in RPM.
From the [RPM manual],

> Expression expansion can be performed using `%[expression]`.  An
> expression consists of terms that can be combined using
> operators.  Rpm supports three kinds of terms, numbers made up
> from digits, strings enclosed in double quotes (eg `"somestring"`) and
> versions enclosed in double quotes preceded by v (eg `v"3:1.2-1"`).
> Rpm will expand macros when evaluating terms.
> 
> You can use the standard operators to combine terms: logical
> operators `&&`, `||`, `!`, relational operators `!=`, `==`, `<`,
> `>`, `<=`, `>=`, arithmetic operators `+`, `-`, `/`, `*`,
> the ternary operator `? :`, and parentheses.
> For example, `%[ 3 + 4 * (1 + %two) ]` will expand
> to "15" if `%two` expands to "2". Version terms are compared using
> rpm version ([epoch:]version[-release]) comparison algorithm,
> rather than regular string comparison.
> 
> Note that the `%[expression]` expansion is different to the
> `%{expr:expression}` macro.  With the latter, the macros in the
> expression are expanded first and then the expression is
> evaluated (without re-expanding the terms).  Thus
> 
> ```sh
> rpm --define 'foo 1 + 2' --eval '%{expr:%foo}'
> ```
> 
> will print "3".  Using `%[%foo]` instead will result in the
> error that "1 + 2" is not a number.
> 
> Doing the macro expansion when evaluating the terms has two
> advantages.  First, it allows rpm to do correct short-circuit
> processing when evaluation logical operators.  Second, the
> expansion result does not influence the expression parsing,
> e.g. `%["%file"]` will even work if the `%file` macro expands
> to a string that contains a double quote.

This section digs into more of the advanced and technical details.

First, a (way simpler) Rust declarative implementation is available
[in `rpmspec-rs`](https://github.com/rpm-rs/rpmspec-rs/blob/master/rpmexpr/src/lib.rs).

<Callout type="info">
  The following section uses the following symbols:
  - üü∞: 2 inputs must be of the same type.
  - üü©: not fallible (i.e. never produces an error), given üü∞ is satisfied.
</Callout>

Second, there are 4 unary, 10 binary, and 1 tertiary operators:
- `-a`: negate a numerical value.
  - Err when used on non-numerical values.
- `!a`: negate the value, return either 1 or 0. üü©
  - Non-zero numbers when negated produce `0`.
  - Non-empty texts/strings when negated produce `0`.
  - Other values (including versions) produce `1`.
- `a && b`: the "and" operator. üü∞üü©
  - Num: `0` unless both values are non-zero.
  - Text: `0` unless both values are not empty.
  - Ver: always produce `a`.
- `a || b`: the "or" operator. üü∞üü©
  - Num: `1` unless both values are zero.
  - Text: `1` unless both values are empty.
  - Ver: always produce `b`.
- `a != b` üü∞üü©
- `a == b` üü∞üü©
- `a < b` üü∞üü©
- `a > b` üü∞üü©
- `a <= b` üü∞üü©
- `a >= b` üü∞üü©
- `a + b` üü∞
  - Num: Addition of 2 numbers
  - Text: Joining 2 texts together (without spaces in the middle)
  - Ver: Err
- `a - b` üü∞
  - The same as `a + (-b)`
- `a / b` üü∞
  - Num: if `b != 0`, performs division.
  - Otherwise err.
- `a * b`
  - Num: performs multiplication.
  - Otherwise err.
- `a ? b : c` üü©
  - `b`, `c` üü∞
  - If `!!a` produces `1`, evaluate to `b`.
  - Otherwise, evaluate to `c`.

[expression]: #rpm-expression
[RPM manual]: https://github.com/rpm-software-management/rpm/blob/b043604b9eb684dc761aeacf55a784632ca0ebcd/docs/manual/macros.md
[^1]: https://docs.fedoraproject.org/en-US/legal/license-field/
[^2]: https://rpm-software-management.github.io/rpm/manual/buildsystem.html
