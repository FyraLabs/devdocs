---
title: RPM Documentations
description: "Documentations on most RPM Features."
---

import { Callout } from "nextra/components";
import { Split } from "../../components/split";

# RPM Documentations

This document covers most if not all useful RPM features.

## Foreword

We understand that RPM, as one of the components in the Fedora / RedHat ecosystem,
is one of the most undocumented packaging systems, and we would like to change that.
We believe by thoroughly documenting Fedora-specific and other RPM macros, we could
make packaging easier to get started for everyone.
Providing the most up-to-date RPM documentations on the Internet could benefit everyone
in the ecosystem, which is why we made this lengthy list of macros.

We provided this document pretty without any restrictions, i.e. you have the freedom
to do whatever you want. However, we would really appreciate if you could also give back
to Terra, packaging a few apps you find possibly useful to other people using Fedora into Terra.

We hope you find this document useful.

## RPM Macros

Technically, there are 3 types of "macros":
- `%{rpm_macro}`: Normal RPM macros
- `%(echo "hi" | sed 's/hi/hello/')`: Shell macros that expands to the output of the commands
- `%[v"1.2.3~1" < v"1.2.3"]`: RPM [expression]

This section only covers the first type.

### Legend

- ğŸ”¢ : Parameterized macro.
- ğŸ”¦ : Relatively uncommon.
- ğŸ”° : Relatively common.
- ğŸš¸ : Not recommended in Terra.
- ğŸ› ï¸ : Advanced.
- ğŸ”© : Usually used with `rpm -E` but not in spec files.

### RPM Internal Macros

<Callout type="info">
  This list is obtained from [rpmspec-rs](https://github.com/rpm-rs/rpmspec-rs/blob/464c8caab5d451517691cc2885bd77912aa53190/src/macros.rs),
  which is obtained from [RPM docs](https://github.com/rpm-software-management/rpm/blob/b043604b9eb684dc761aeacf55a784632ca0ebcd/docs/manual/macros.md#builtin-macros).
</Callout>

#### `%define` ğŸ”°

Defines a macro locally.

Macros defined with `%define` will not last to another RPM section.
For example, if used in preamble section, the macro will be automatically undefined in `%prep`.

To make sure a macro lasts for the entire spec file, use `%global` instead.

<Split>
  <Split.Left>
    ```rpmspec filename="example.spec"
    %build
    %define my_macro Hello, World!
    echo %my_macro

    %install
    echo %my_macro
    ```
  </Split.Left>
  <Split.Right>
    ```rpmspec filename="expand.spec"
    %build
    echo Hello, World!

    %install
    echo %my_macro
    ```
  </Split.Right>
</Split>

#### `%global` ğŸ”°

Defines a macro globally.

As oppose to `%define`, macros defined with `%global` will last for the entire spec file.

<Split>
  <Split.Left>
    ```rpmspec filename="example.spec"
    %global cat Meow!!!

    %prep
    echo nya %cat

    %build
    echo %cat
    ```
  </Split.Left>
  <Split.Right>
    ```rpmspec filename="expand.spec"
    %prep
    echo nya Meow!!!

    %build
    echo Meow!!!
    ```
  </Split.Right>
</Split>

#### `%undefine` ğŸ”¦

Undefine a macro.

Technically this does not always undefine the macro specified.
Instead, this pops the latest definition from the macro stack.

<Split>
  <Split.Left>
    ```rpmspec filename="example.spec"
    %global cat Meow!

    %prep
    %global cat Nyaa!
    echo %cat

    %build
    %undefine cat
    echo %cat

    %install
    %undefine cat
    echo %cat
    ```
  </Split.Left>
  <Split.Right>
    ```rpmspec filename="expand.spec"
    %prep
    echo Nyaa!

    %build
    echo Meow!

    %install
    echo %cat
    ```
  </Split.Right>
</Split>

#### `%dnl` ğŸ”°

Comments.

Similar to `# â€¦`, this can comment out anything in `%{dnl:â€¦}` or after `%dnl â€¦`.
The difference with `# â€¦` is that `%dnl` prevents macro expansions,
while macros in `# â€¦` are actually expanded.

<Split>
  <Split.Left>
    ```rpmspec filename="example.spec"
    %define meow a
    # comment %meow
    %dnl comment %meow
    ```
  </Split.Left>
  <Split.Right>
    ```rpmspec filename="expand.spec"
    # comment a
    ```
  </Split.Right>
</Split>

#### `%{load:â€¦}` ğŸ”¦ğŸš¸

Load a macro file.

#### `%{expr:â€¦}` ğŸ”¦

Expand all macros in the body, then evaluate the body as an [expression].

  ```sh
  $ rpm -D 'foo 1 + 2' -E '%[%foo]'
  error: macro expansion did not return an integer: %foo
  error:                                            ^
  error: expanded string: 1 + 2

  $ rpm -D 'foo 1 + 2' -E '%{expr:%foo}'
  3
  ```

#### `%{expand:â€¦}` ğŸ”¦ğŸ› ï¸

  Double-expand the macro.

  <Split>
    <Split.Left>
      ```rpmspec filename="example.spec"
      %define nya foo
      %define meow %{expand:%%nya}
    
      echo %meow
      ```
    </Split.Left>
    <Split.Right>
      ```rpmspec filename="expand.spec"
      echo foo
      ```
    </Split.Right>
  </Split>

#### `%{lua:â€¦}` ğŸ› ï¸

Embed lua code.

<Callout type="warning">
  Since RPM expands macros when the source RPM (SRPM) is created,
  the lua code is executed during that stage.

  This means that the lua code is executed not during the stage it is defined in, but
  way before even `%prep`.
</Callout>
<Callout type="warning">
  Do NOT comment out lua code using `# â€¦`, `%dnl â€¦` or `%{dnl:â€¦}`.

  Lua comments must start with `-- â€¦`.

  In unstable (i.e. older) versions of `rpmspec-rs`, a space must be present after `--`.
</Callout>
<Callout type="info">
  Documentations for the embedded Lua interpreter, including specific functions available,
  are available at https://rpm-software-management.github.io/rpm/manual/lua.html.
</Callout>

<Split>
  <Split.Left>
    ```rpmspec filename="example.spec"
    %global my_macro Hello
    %{lua:
      -- this lua block expands to the input
      -- to all `print()` statements
      print("%prep\necho " ..
        rpm.expand("%my_macro from lua!") ..
        "\n")
    }
    ```
  </Split.Left>
  <Split.Right>
    ```rpmspec filename="expand.spec"
    %prep
    echo Hello from lua!
    ```
  </Split.Right>
</Split>

#### `%{macrobody:â€¦}` ğŸ”©

Expand to the definition of the given macro

```sh
$ rpm -E '%dist'
.um41

$ rpm -E '%macrobody dist'
%{?distprefix}.um41%{?with_bootstrap:~bootstrap}
```

## RPM Expression

RPM expressions is a "sublanguage" in RPM.
From the [RPM manual](https://github.com/rpm-software-management/rpm/blob/b043604b9eb684dc761aeacf55a784632ca0ebcd/docs/manual/macros.md#expression-expansion),

> Expression expansion can be performed using `%[expression]`.  An
> expression consists of terms that can be combined using
> operators.  Rpm supports three kinds of terms, numbers made up
> from digits, strings enclosed in double quotes (eg `"somestring"`) and
> versions enclosed in double quotes preceded by v (eg `v"3:1.2-1"`).
> Rpm will expand macros when evaluating terms.
> 
> You can use the standard operators to combine terms: logical
> operators `&&`, `||`, `!`, relational operators `!=`, `==`, `<`,
> `>`, `<=`, `>=`, arithmetic operators `+`, `-`, `/`, `*`,
> the ternary operator `? :`, and parentheses.
> For example, `%[ 3 + 4 * (1 + %two) ]` will expand
> to "15" if `%two` expands to "2". Version terms are compared using
> rpm version ([epoch:]version[-release]) comparison algorithm,
> rather than regular string comparison.
> 
> Note that the `%[expression]` expansion is different to the
> `%{expr:expression}` macro.  With the latter, the macros in the
> expression are expanded first and then the expression is
> evaluated (without re-expanding the terms).  Thus
> 
> ```sh
> rpm --define 'foo 1 + 2' --eval '%{expr:%foo}'
> ```
> 
> will print "3".  Using `%[%foo]` instead will result in the
> error that "1 + 2" is not a number.
> 
> Doing the macro expansion when evaluating the terms has two
> advantages.  First, it allows rpm to do correct short-circuit
> processing when evaluation logical operators.  Second, the
> expansion result does not influence the expression parsing,
> e.g. `%["%file"]` will even work if the `%file` macro expands
> to a string that contains a double quote.

This section digs into more of the advanced and technical details.

First, a (way simpler) Rust declarative implementation is available
[in `rpmspec-rs`](https://github.com/rpm-rs/rpmspec-rs/blob/master/rpmexpr/src/lib.rs).

<Callout type="info">
  The following section uses the following symbols:
  - ğŸŸ°: for unary operators, the inputs must be of the same type.
  - ğŸŸ©: not fallible (i.e. never produces an error), given ğŸŸ° is satisfied.
</Callout>

Second, there are 4 unary, 10 binary, and 1 tertiary operators:
- `-val`: negate a numerical value.
  - Err when used on non-numerical values.
- `!val`: negate the value, return either 1 or 0. ğŸŸ©
  - Non-zero numbers when negated produce `0`.
  - Non-empty texts/strings when negated produce `0`.
  - Other values (including versions) produce `1`.
- `a && b`: the "and" operator. ğŸŸ°ğŸŸ©
  - Num: `0` unless both values are non-zero.
  - Text: `0` unless both values are not empty.
  - Ver: always produce `a`.
- `a || b`: the "or" operator. ğŸŸ°ğŸŸ©
  - Num: `1` unless both values are zero.
  - Text: `1` unless both values are empty.
  - Ver: always produce `b`.
- `a != b` ğŸŸ°ğŸŸ©
- `a == b` ğŸŸ°ğŸŸ©
- `a < b` ğŸŸ°ğŸŸ©
- `a > b` ğŸŸ°ğŸŸ©
- `a <= b` ğŸŸ°ğŸŸ©
- `a >= b` ğŸŸ°ğŸŸ©
- `a + b` ğŸŸ°
  - Num: Addition of 2 numbers
  - Text: Joining 2 texts together (without spaces in the middle)
  - Ver: Err
- `a - b` ğŸŸ°
  - The same as `a + (-b)`
- `a / b` ğŸŸ°
  - Num: if `b != 0`, performs division.
  - Otherwise err.
- `a * b`
  - Num: performs multiplication.
  - Otherwise err.
- `a ? b : c` ğŸŸ©
  - `b`, `c` ğŸŸ°
  - If `!!a` produces `1`, evaluate to `b`.
  - Otherwise, evalute to `c`.

[expression]: #rpm-expression
